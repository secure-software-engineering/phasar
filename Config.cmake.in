set(PHASAR_VERSION 1.0.0)

@PACKAGE_INIT@
set_and_check(PHASAR_INCLUDE_DIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
set_and_check(PHASAR_LIBRARY_DIR "@PACKAGE_LIBRARY_INSTALL_DIR@")

include (CMakeFindDependencyMacro)
find_dependency(nlohmann_json)
find_dependency(nlohmann_json_schema_validator)

find_package(Boost 1.65.1 COMPONENTS graph REQUIRED)
find_package(LLVM 14 REQUIRED CONFIG)

set(PHASAR_USE_LLVM_FAT_LIB @USE_LLVM_FAT_LIB@)
set(PHASAR_BUILD_DYNLIB @PHASAR_BUILD_DYNLIB@)

# TODO: The order seems to be important in the include'ing loop below. Fix this!

set(PHASAR_COMPONENTS
  utils
  passes
  config
  db
  pointer
  controlflow

  llvm_utils
  llvm_db
  llvm_pointer
  llvm_typehierarchy
  llvm_controlflow

  taintconfig
  mono
  llvm
  llvm_ifdside
  analysis_strategy
  controller
)

list(REMOVE_DUPLICATES phasar_FIND_COMPONENTS)

foreach(component ${phasar_FIND_COMPONENTS})
  if(NOT ${component} IN_LIST PHASAR_COMPONENTS)
    message(FATAL_ERROR "Requested component ${component} is no valid PHASAR component. Valid components are: ${PHASAR_COMPONENTS}")
    break()
  endif()
endforeach()

foreach(component ${PHASAR_COMPONENTS})
  include("${CMAKE_CURRENT_LIST_DIR}/phasar_${component}-targets.cmake")
endforeach()

foreach(component ${phasar_FIND_COMPONENTS})
  list(APPEND PHASAR_NEEDED_LIBS phasar::phasar_${component})
endforeach()

function(phasar_config executable)
  target_link_libraries(${executable}
    PUBLIC
      ${PHASAR_NEEDED_LIBS}
  )

  # TODO: Use target_include_directories from withing phasar already, such that phasar_config is no longer necessary in the future
  target_include_directories(${executable}
    PUBLIC
      ${PHASAR_INCLUDE_DIR}
  )
endfunction()
